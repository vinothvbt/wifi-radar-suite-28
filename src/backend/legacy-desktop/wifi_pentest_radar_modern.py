#!/usr/bin/env python3
"""
WiFi Penetration Testing Radar - Modern Professional Edition v4.0
Industry-level tool with modern UI, advanced radar visualization, and enhanced functionality
"""

import sys
import os
import json
import re
import subprocess
import time
import math
import logging
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Tuple
from datetime import datetime
import sqlite3

# Import configuration and engine modules
try:
    from config_manager import config_manager
    from vendor_service import vendor_service  
    from security_engine import security_engine
    from distance_engine import distance_engine
    from settings_dialog import AdvancedSettingsDialog
    from terminal_widget import EmbeddedTerminal
except ImportError as e:
    print(f"Error importing engine modules: {e}")
    print("Please ensure all engine modules are in the same directory.")
    sys.exit(1)

try:
    from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, 
                                QHBoxLayout, QLabel, QComboBox, QSpinBox, QPushButton,
                                QTextEdit, QTabWidget, QTableWidget, QTableWidgetItem,
                                QHeaderView, QSplitter, QFrame, QGroupBox, QCheckBox,
                                QMenuBar, QMenu, QAction, QToolBar, QStatusBar, QShortcut,
                                QMessageBox, QDialog, QDialogButtonBox, QSizePolicy,
                                QScrollArea, QGridLayout, QProgressBar, QSlider, QFileDialog)
    from PyQt5.QtCore import QTimer, QThread, pyqtSignal, Qt, QMutex, QRect, QPoint, QSize, QPropertyAnimation, QEasingCurve, pyqtProperty
    from PyQt5.QtGui import QPainter, QColor, QPen, QBrush, QFont, QPixmap, QKeySequence, QIcon, QPainterPath, QLinearGradient, QRadialGradient, QClipboard
except ImportError:
    print("Error: PyQt5 not found. Install with: pip install PyQt5")
    sys.exit(1)

# Configure logging
try:
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler('/tmp/wifi_pentest_radar.log'),
            logging.StreamHandler()
        ]
    )
except PermissionError:
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

logger = logging.getLogger(__name__)

@dataclass
class AccessPoint:
    """Access Point data structure for penetration testing analysis"""
    bssid: str
    ssid: str
    signal_dbm: float
    frequency: int
    security: str
    distance: float = 0.0
    angle: float = 0.0
    vendor: str = "Unknown"
    vulnerability_score: int = 0
    attack_vectors: List[str] = field(default_factory=list)
    threat_level: str = "LOW"
    last_seen: datetime = field(default_factory=datetime.now)
    confidence: float = 0.0
    x_pos: float = 0.0
    y_pos: float = 0.0

class WiFiScanner(QThread):
    """Background WiFi scanning thread using configuration-driven approach"""
    access_points_found = pyqtSignal(list)
    scan_error = pyqtSignal(str)
    
    def __init__(self):
        super().__init__()
        self._mutex = QMutex()
        self._running = False
        self._interface = None
        self._scan_interval = 5
        self._available_interfaces = []
        
        # Get configuration
        self.config = config_manager
        self.patterns = self.config.get_parsing_patterns()
        self.security_keywords = self.config.get_security_keywords()
        self.scan_timeout = self.config.get_scan_timeout()
        
        # Compile regex patterns for efficiency
        self._compile_patterns()
        
        # Detect interfaces
        self._detect_interfaces()
        
    def _compile_patterns(self):
        """Compile regex patterns for efficient parsing"""
        try:
            self.mac_pattern = re.compile(self.patterns.get("mac_address", r"([0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2})"))
            self.signal_pattern = re.compile(self.patterns.get("signal_strength", r"signal:\s*(-\d+\.?\d*)\s*dBm"))
            self.freq_pattern = re.compile(self.patterns.get("frequency", r"freq:\s*(\d+)"))
            self.ssid_pattern = re.compile(self.patterns.get("ssid", r"SSID:\s*(.+)"))
        except re.error as e:
            logger.error(f"Error compiling regex patterns: {e}")
            # Fallback to simple patterns
            self.mac_pattern = re.compile(r"([0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2})")
            self.signal_pattern = re.compile(r"signal:\s*(-\d+\.?\d*)\s*dBm")
            self.freq_pattern = re.compile(r"freq:\s*(\d+)")
            self.ssid_pattern = re.compile(r"SSID:\s*(.+)")
    
    def _detect_interfaces(self):
        """Detect available wireless interfaces using multiple methods"""
        try:
            # Method 1: iw dev
            self._try_iw_detection()
            
            # Method 2: iwconfig (fallback)
            if not self._available_interfaces:
                self._try_iwconfig_detection()
            
            # Method 3: Check /sys/class/net (last resort)
            if not self._available_interfaces:
                self._try_sys_detection()
            
            if self._available_interfaces:
                self._interface = self._available_interfaces[0]
                logger.info(f"Detected interfaces: {self._available_interfaces}")
                logger.info(f"Using interface: {self._interface}")
            else:
                logger.error("No wireless interfaces detected")
                
        except Exception as e:
            logger.error(f"Interface detection failed: {e}")
    
    def _try_iw_detection(self):
        """Try detecting interfaces using iw command"""
        try:
            result = subprocess.run(['iw', 'dev'], capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                for line in result.stdout.split('\n'):
                    if 'Interface' in line:
                        interface = line.split()[-1]
                        if interface and interface not in self._available_interfaces:
                            self._available_interfaces.append(interface)
        except (subprocess.TimeoutExpired, FileNotFoundError, subprocess.SubprocessError):
            pass
    
    def _try_iwconfig_detection(self):
        """Try detecting interfaces using iwconfig command"""
        try:
            result = subprocess.run(['iwconfig'], capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                for line in result.stdout.split('\n'):
                    if 'IEEE 802.11' in line:
                        interface = line.split()[0]
                        if interface and interface not in self._available_interfaces:
                            self._available_interfaces.append(interface)
        except (subprocess.TimeoutExpired, FileNotFoundError, subprocess.SubprocessError):
            pass
    
    def _try_sys_detection(self):
        """Try detecting interfaces from /sys/class/net"""
        try:
            common_names = ['wlan0', 'wlan1', 'wlp2s0', 'wlp3s0', 'wifi0', 'wlx']
            for name in common_names:
                if name == 'wlx':
                    # Check for USB WiFi adapters with pattern wlx*
                    try:
                        for entry in os.listdir('/sys/class/net'):
                            if entry.startswith('wlx'):
                                self._available_interfaces.append(entry)
                    except OSError:
                        pass
                else:
                    if os.path.exists(f'/sys/class/net/{name}'):
                        # Verify it's a wireless interface
                        if os.path.exists(f'/sys/class/net/{name}/wireless'):
                            self._available_interfaces.append(name)
        except Exception:
            pass
    
    def get_available_interfaces(self) -> List[str]:
        """Get list of available wireless interfaces"""
        return self._available_interfaces.copy()
    
    def set_interface(self, interface: str):
        """Set the interface to use for scanning"""
        if interface in self._available_interfaces:
            self._interface = interface
            logger.info(f"Interface changed to: {interface}")
        else:
            logger.error(f"Interface {interface} not available")
    
    def set_scan_interval(self, interval: int):
        """Set scanning interval in seconds"""
        self._scan_interval = max(1, interval)
    
    def start_scanning(self):
        """Start the scanning thread"""
        if not self._available_interfaces:
            self.scan_error.emit("No wireless interfaces available")
            return
        
        self._mutex.lock()
        try:
            if not self._running:
                self._running = True
                self.start()
                logger.info("WiFi scanning started")
        finally:
            self._mutex.unlock()
    
    def stop_scanning(self):
        """Stop the scanning thread"""
        self._mutex.lock()
        try:
            self._running = False
        finally:
            self._mutex.unlock()
        self.wait()
        logger.info("WiFi scanning stopped")
    
    def run(self):
        """Main scanning loop"""
        while self._running:
            try:
                access_points = self._perform_scan()
                if access_points:
                    self.access_points_found.emit(access_points)
                
                # Sleep with frequent checks to allow quick stopping
                for _ in range(self._scan_interval * 10):
                    if not self._running:
                        break
                    self.msleep(100)  # 100ms
                    
            except Exception as e:
                logger.error(f"Scan error: {e}")
                self.scan_error.emit(str(e))
                self.msleep(1000)  # Wait 1 second before retrying
    
    def _perform_scan(self) -> List[AccessPoint]:
        """Perform a single WiFi scan"""
        try:
            if not self._interface:
                raise Exception("No interface available for scanning")
            
            # Get scan command from configuration
            cmd = self.config.get_scan_command(self._interface)
            
            logger.debug(f"Executing scan command: {' '.join(cmd)}")
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=self.scan_timeout)
            
            if result.returncode != 0:
                raise Exception(f"Scan command failed: {result.stderr.strip()}")
            
            return self._parse_scan_output(result.stdout)
            
        except subprocess.TimeoutExpired:
            raise Exception("Scan timeout - interface may be busy")
        except FileNotFoundError:
            raise Exception("Scan command not found - install wireless tools")
        except Exception as e:
            raise Exception(f"Scan error: {str(e)}")
    
    def _parse_scan_output(self, output: str) -> List[AccessPoint]:
        """Parse scan output into AccessPoint objects using configured patterns"""
        access_points = []
        current_ap = {}
        
        for line in output.split('\n'):
            line = line.strip()
            
            if line.startswith('BSS '):
                # Save previous AP if exists
                if current_ap:
                    ap = self._create_access_point(current_ap)
                    if ap:
                        access_points.append(ap)
                
                # Start new AP
                bssid_match = self.mac_pattern.search(line)
                current_ap = {'bssid': bssid_match.group(1) if bssid_match else 'Unknown'}
                
            elif 'signal:' in line:
                signal_match = self.signal_pattern.search(line)
                if signal_match:
                    current_ap['signal'] = float(signal_match.group(1))
                    
            elif 'freq:' in line:
                freq_match = self.freq_pattern.search(line)
                if freq_match:
                    current_ap['frequency'] = int(freq_match.group(1))
                    
            elif line.startswith('SSID:'):
                ssid_match = self.ssid_pattern.search(line)
                current_ap['ssid'] = ssid_match.group(1).strip() if ssid_match else 'Hidden'
                
            else:
                # Detect security using configured keywords
                current_ap['security'] = self._detect_security(line, current_ap.get('security', 'Open'))
        
        # Don't forget the last AP
        if current_ap:
            ap = self._create_access_point(current_ap)
            if ap:
                access_points.append(ap)
        
        logger.info(f"Parsed {len(access_points)} access points")
        return access_points
    
    def _detect_security(self, line: str, current_security: str) -> str:
        """Detect security type using configured keywords"""
        line_upper = line.upper()
        
        # Check in order of preference (most secure first)
        for security_type, keywords in self.security_keywords.items():
            if security_type == 'Open':
                continue  # Handle Open as default
            
            for keyword in keywords:
                if keyword.upper() in line_upper:
                    return security_type
        
        return current_security  # Keep existing or default to Open
    
    def _create_access_point(self, ap_data: Dict) -> Optional[AccessPoint]:
        """Create AccessPoint object from parsed data using engine services"""
        try:
            # Extract basic data with defaults
            bssid = ap_data.get('bssid', 'Unknown')
            ssid = ap_data.get('ssid', 'Hidden')
            signal = ap_data.get('signal', -100.0)
            frequency = ap_data.get('frequency', 2437)  # Default to channel 6
            security = ap_data.get('security', 'Open')
            
            # Skip invalid entries
            if bssid == 'Unknown' or signal < -120:
                return None
            
            # Calculate distance using distance engine
            distance = distance_engine.calculate_distance(signal, frequency)
            
            # Generate consistent angle for radar positioning
            angle = distance_engine.calculate_angle_from_mac(bssid)
            
            # Get vendor information
            vendor_info = vendor_service.get_vendor_info(bssid)
            vendor = vendor_info['vendor']
            
            # Perform security analysis
            security_result = security_engine.analyze_access_point(
                ssid, bssid, security, signal, frequency
            )
            
            # Calculate channel from frequency (approximate)
            channel = self._frequency_to_channel(frequency)
            
            # Create AccessPoint object
            ap = AccessPoint(
                bssid=bssid,
                ssid=ssid,
                signal_dbm=signal,
                frequency=frequency,
                security=security,
                distance=distance,
                angle=angle,
                vendor=vendor,
                vulnerability_score=security_result.vulnerability_score,
                attack_vectors=security_result.attack_vectors,
                threat_level=security_result.threat_level,
                confidence=security_result.confidence,
                last_seen=datetime.now()
            )
            
            # Calculate radar position
            ap.x_pos, ap.y_pos = self._calculate_radar_position(angle, distance)
            
            return ap
            
        except Exception as e:
            logger.error(f"Error creating AccessPoint from {ap_data}: {e}")
            return None
    
    def _frequency_to_channel(self, frequency: int) -> int:
        """Convert frequency to WiFi channel number"""
        if 2412 <= frequency <= 2484:
            # 2.4 GHz band
            if frequency == 2484:
                return 14
            else:
                return (frequency - 2412) // 5 + 1
        elif 5000 <= frequency <= 6000:
            # 5 GHz band (simplified)
            return (frequency - 5000) // 5
        else:
            return 0  # Unknown
    
    def _calculate_radar_position(self, angle: float, distance: float) -> Tuple[float, float]:
        """Calculate x,y position for radar display"""
        # Convert polar to cartesian coordinates
        angle_rad = math.radians(angle)
        x = distance * math.cos(angle_rad)
        y = distance * math.sin(angle_rad)
        return x, y
        
    def set_interface(self, interface: str):
        if interface in self._available_interfaces:
            self._interface = interface
            logger.info(f"Interface changed to: {interface}")
            
    def set_scan_interval(self, interval: int):
        self._scan_interval = max(1, min(30, interval))


class ModernRadarWidget(QWidget):
    """Modern radar display widget with advanced visualization"""
    ap_selected = pyqtSignal(AccessPoint)
    
    def __init__(self):
        super().__init__()
        self.setMinimumSize(600, 600)
        self.access_points = []
        self.selected_ap = None
        self.range_meters = 100
        self.sweep_angle = 0
        self.radar_size = 600
        self.zoom_level = 1.0
        
        # Set object name for styling
        self.setObjectName("radarWidget")
        
        # Animation timer
        self.timer = QTimer()
        self.timer.timeout.connect(self._update_sweep)
        self.timer.start(50)  # 20 FPS
        
        # Modern threat level colors
        self.threat_colors = {
            'CRITICAL': QColor(231, 76, 60),    # Modern red
            'HIGH': QColor(243, 156, 18),       # Modern orange
            'MEDIUM': QColor(241, 196, 15),     # Modern yellow
            'LOW': QColor(39, 174, 96)          # Modern green
        }
        
        # Grid visualization mode
        self.visualization_mode = "GRID"  # GRID, POLAR, HEATMAP
        
    def set_radar_size(self, size: int):
        """Set radar display size for different view modes"""
        self.radar_size = size
        self.setMinimumSize(size, size)
        self.update()
        
    def set_range(self, range_meters: int):
        self.range_meters = range_meters
        self._recalculate_positions()
        self.update()
        
    def set_visualization_mode(self, mode: str):
        """Set visualization mode: GRID, POLAR, HEATMAP"""
        self.visualization_mode = mode
        self._recalculate_positions()
        self.update()
        
    def update_access_points(self, access_points: List[AccessPoint]):
        self.access_points = access_points
        self._recalculate_positions()
        self.update()
        
    def _recalculate_positions(self):
        """Recalculate AP positions to prevent overlapping"""
        if not self.access_points:
            return
            
        # Sort APs by signal strength (strongest first)
        sorted_aps = sorted(self.access_points, key=lambda ap: ap.signal_dbm, reverse=True)
        
        # Calculate positions based on visualization mode
        if self.visualization_mode == "GRID":
            self._calculate_grid_positions(sorted_aps)
        elif self.visualization_mode == "POLAR":
            self._calculate_polar_positions(sorted_aps)
        elif self.visualization_mode == "HEATMAP":
            self._calculate_heatmap_positions(sorted_aps)
            
    def _calculate_grid_positions(self, aps: List[AccessPoint]):
        """Calculate grid-based positions to prevent overlapping"""
        size = min(self.width(), self.height())
        center_x = size // 2
        center_y = size // 2
        
        # Create a grid for positioning
        grid_size = 20  # Grid cell size
        occupied_cells = set()
        
        for ap in aps:
            # Calculate ideal position based on distance and angle
            scale = (center_x - 50) / self.range_meters
            ideal_x = center_x + math.cos(math.radians(ap.angle)) * ap.distance * scale
            ideal_y = center_y + math.sin(math.radians(ap.angle)) * ap.distance * scale
            
            # Find nearest available grid cell
            grid_x = int(ideal_x // grid_size)
            grid_y = int(ideal_y // grid_size)
            
            # Search for available cell in expanding spiral
            for radius in range(10):
                for dx in range(-radius, radius + 1):
                    for dy in range(-radius, radius + 1):
                        if abs(dx) == radius or abs(dy) == radius:
                            test_x = grid_x + dx
                            test_y = grid_y + dy
                            if (test_x, test_y) not in occupied_cells:
                                occupied_cells.add((test_x, test_y))
                                ap.x_pos = test_x * grid_size + grid_size // 2
                                ap.y_pos = test_y * grid_size + grid_size // 2
                                break
                    else:
                        continue
                    break
                else:
                    continue
                break
                
    def _calculate_polar_positions(self, aps: List[AccessPoint]):
        """Calculate polar positions with distance-based rings"""
        size = min(self.width(), self.height())
        center_x = size // 2
        center_y = size // 2
        
        # Group APs by distance ranges
        distance_rings = {}
        ring_size = self.range_meters / 5  # 5 rings
        
        for ap in aps:
            ring = int(ap.distance / ring_size)
            if ring not in distance_rings:
                distance_rings[ring] = []
            distance_rings[ring].append(ap)
            
        # Position APs in each ring
        for ring, ring_aps in distance_rings.items():
            ring_radius = (ring + 1) * (center_x - 50) / 5
            angle_step = 360 / max(len(ring_aps), 1)
            
            for i, ap in enumerate(ring_aps):
                angle = i * angle_step
                ap.x_pos = center_x + math.cos(math.radians(angle)) * ring_radius
                ap.y_pos = center_y + math.sin(math.radians(angle)) * ring_radius
                
    def _calculate_heatmap_positions(self, aps: List[AccessPoint]):
        """Calculate positions for heatmap visualization"""
        size = min(self.width(), self.height())
        center_x = size // 2
        center_y = size // 2
        
        # Use signal strength to determine clustering
        for ap in aps:
            # Stronger signals closer to center
            signal_factor = (ap.signal_dbm + 100) / 100  # Normalize to 0-1
            max_radius = center_x - 50
            
            # Add some randomization to prevent exact overlaps
            angle_offset = (hash(ap.bssid) % 60) - 30  # ±30 degrees
            final_angle = ap.angle + angle_offset
            
            radius = max_radius * (1 - signal_factor * 0.7)  # Stronger signals closer
            
            ap.x_pos = center_x + math.cos(math.radians(final_angle)) * radius
            ap.y_pos = center_y + math.sin(math.radians(final_angle)) * radius
        
    def _update_sweep(self):
        self.sweep_angle = (self.sweep_angle + 2) % 360
        self.update()
        
    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        
        # Get current size
        size = min(self.width(), self.height())
        center_x = size // 2
        center_y = size // 2
        
        # Modern dark background with gradient
        gradient = QRadialGradient(center_x, center_y, center_x)
        gradient.setColorAt(0, QColor(26, 26, 26))
        gradient.setColorAt(1, QColor(16, 16, 16))
        painter.fillRect(self.rect(), QBrush(gradient))
        
        # Draw visualization based on mode
        if self.visualization_mode == "GRID":
            self._draw_grid_visualization(painter, center_x, center_y, size)
        elif self.visualization_mode == "POLAR":
            self._draw_polar_visualization(painter, center_x, center_y, size)
        elif self.visualization_mode == "HEATMAP":
            self._draw_heatmap_visualization(painter, center_x, center_y, size)
            
        # Draw access points
        self._draw_access_points_modern(painter, center_x, center_y, size)
        
    def _draw_grid_visualization(self, painter, center_x, center_y, size):
        """Draw modern grid visualization"""
        painter.setPen(QPen(QColor(0, 212, 170, 50), 1))
        
        # Draw grid lines
        grid_spacing = 40
        for x in range(0, size, grid_spacing):
            painter.drawLine(x, 0, x, size)
        for y in range(0, size, grid_spacing):
            painter.drawLine(0, y, size, y)
            
        # Draw center crosshair
        painter.setPen(QPen(QColor(0, 212, 170, 150), 2))
        painter.drawLine(center_x - 20, center_y, center_x + 20, center_y)
        painter.drawLine(center_x, center_y - 20, center_x, center_y + 20)
        
        # Draw range circles
        painter.setPen(QPen(QColor(0, 212, 170, 100), 1))
        for i in range(1, 5):
            radius = (center_x - 50) * i / 4
            painter.drawEllipse(int(center_x - radius), int(center_y - radius), int(radius * 2), int(radius * 2))
            
    def _draw_polar_visualization(self, painter, center_x, center_y, size):
        """Draw modern polar radar visualization matching the screenshot"""
        # Use cyan/blue colors to match the screenshot
        ring_color = QColor(0, 180, 200, 120)  # Cyan rings
        line_color = QColor(0, 180, 200, 80)   # Cyan lines
        
        painter.setRenderHint(QPainter.Antialiasing)
        
        # Draw range circles (like in screenshot)
        painter.setPen(QPen(ring_color, 2))
        max_radius = min(center_x, center_y) - 20
        
        for i in range(1, 6):
            radius = max_radius * i / 5
            painter.drawEllipse(int(center_x - radius), int(center_y - radius), int(radius * 2), int(radius * 2))
        
        # Draw angle lines every 30 degrees
        painter.setPen(QPen(line_color, 1))
        for angle in range(0, 360, 30):
            end_x = center_x + math.cos(math.radians(angle)) * max_radius
            end_y = center_y + math.sin(math.radians(angle)) * max_radius
            painter.drawLine(center_x, center_y, int(end_x), int(end_y))
        
        # Draw center point
        painter.setPen(QPen(QColor(0, 200, 255), 3))
        painter.setBrush(QBrush(QColor(0, 200, 255)))
        painter.drawEllipse(center_x - 3, center_y - 3, 6, 6)
        
    def _draw_heatmap_visualization(self, painter, center_x, center_y, size):
        """Draw heatmap-style visualization"""
        # Draw background heatmap based on signal strength
        for ap in self.access_points:
            if hasattr(ap, 'x_pos') and hasattr(ap, 'y_pos'):
                # Create gradient based on signal strength
                signal_strength = (ap.signal_dbm + 100) / 100  # Normalize
                radius = 30 + signal_strength * 20
                
                gradient = QRadialGradient(ap.x_pos, ap.y_pos, radius)
                color = self.threat_colors.get(ap.threat_level, QColor(255, 255, 255))
                color.setAlpha(30)
                gradient.setColorAt(0, color)
                color.setAlpha(0)
                gradient.setColorAt(1, color)
                
                painter.setBrush(QBrush(gradient))
                painter.setPen(Qt.NoPen)
                painter.drawEllipse(int(ap.x_pos - radius), int(ap.y_pos - radius), int(radius * 2), int(radius * 2))
                
    def _draw_modern_sweep(self, painter, center_x, center_y, size):
        """Draw modern animated radar sweep"""
        # Create sweep gradient
        sweep_gradient = QLinearGradient()
        sweep_gradient.setColorAt(0, QColor(0, 212, 170, 0))
        sweep_gradient.setColorAt(0.8, QColor(0, 212, 170, 100))
        sweep_gradient.setColorAt(1, QColor(0, 212, 170, 200))
        
        painter.setPen(QPen(QBrush(sweep_gradient), 3))
        
        # Calculate sweep line endpoint
        angle_rad = math.radians(self.sweep_angle)
        end_x = center_x + math.cos(angle_rad) * (center_x - 50)
        end_y = center_y + math.sin(angle_rad) * (center_y - 50)
        
        # Draw main sweep line
        painter.drawLine(center_x, center_y, int(end_x), int(end_y))
        
        # Draw fade trail
        for i in range(1, 15):
            trail_angle = self.sweep_angle - i * 4
            trail_rad = math.radians(trail_angle)
            trail_end_x = center_x + math.cos(trail_rad) * (center_x - 50)
            trail_end_y = center_y + math.sin(trail_rad) * (center_y - 50)
            
            alpha = max(0, 150 - i * 10)
            painter.setPen(QPen(QColor(0, 212, 170, alpha), 2))
            painter.drawLine(center_x, center_y, int(trail_end_x), int(trail_end_y))
            
    def _draw_access_points_modern(self, painter, center_x, center_y, size):
        """Draw access points with screenshot-style coloring"""
        painter.setRenderHint(QPainter.Antialiasing)
        
        # Update threat colors to match screenshot
        threat_colors = {
            'CRITICAL': QColor(255, 68, 68),   # Red
            'HIGH': QColor(255, 136, 68),      # Orange  
            'MEDIUM': QColor(255, 170, 0),     # Yellow
            'LOW': QColor(255, 170, 0)         # Yellow (less vulnerable)
        }
        
        max_radius = min(center_x, center_y) - 20
        
        for ap in self.access_points:
            # Map AP position to radar coordinates using distance and angle
            distance_ratio = min(ap.distance / self.range_meters, 1.0)
            ap_radius = distance_ratio * max_radius
            
            # Use angle from AP data or generate based on BSSID
            angle = getattr(ap, 'angle', hash(ap.bssid) % 360)
            angle_rad = math.radians(angle)
            
            x = center_x + math.cos(angle_rad) * ap_radius
            y = center_y + math.sin(angle_rad) * ap_radius
            
            # Store calculated coordinates for click detection
            ap.x_pos = x
            ap.y_pos = y
            
            # Get color based on threat level
            color = threat_colors.get(ap.threat_level, QColor(255, 170, 0))
            
            # Draw AP dot
            dot_size = 12 if ap == self.selected_ap else 8
            painter.setPen(QPen(color, 2))
            painter.setBrush(QBrush(color))
            painter.drawEllipse(int(x - dot_size/2), int(y - dot_size/2), dot_size, dot_size)
            
            # Draw SSID label for selected or strong signals
            if ap == self.selected_ap or ap.signal_dbm > -60:
                painter.setPen(QColor(255, 255, 255))
                painter.setFont(QFont('Arial', 9))
                
                # Position label to avoid overlapping with dot
                label_x = int(x + 15)
                label_y = int(y - 5)
                
                painter.drawText(label_x, label_y, ap.ssid[:15])
                
    def _draw_modern_info(self, painter):
        """Draw modern information panel"""
        painter.setPen(QColor(255, 255, 255, 200))
        painter.setFont(QFont('Segoe UI', 10, QFont.Medium))
        
        # Create info background
        info_rect = QRect(10, 10, 200, 180)
        painter.setBrush(QBrush(QColor(0, 0, 0, 100)))
        painter.setPen(QPen(QColor(0, 212, 170), 1))
        painter.drawRoundedRect(info_rect, 8, 8)
        
        # Draw info text
        painter.setPen(QColor(255, 255, 255))
        info_lines = [
            f"Range: {self.range_meters}m",
            f"APs Found: {len(self.access_points)}",
            f"Mode: {self.visualization_mode}",
            f"Sweep: {self.sweep_angle:03d}°",
            "",
            "Threat Levels:",
            "● CRITICAL",
            "● HIGH", 
            "● MEDIUM",
            "● LOW"
        ]
        
        y_offset = 25
        for i, line in enumerate(info_lines):
            if line.startswith("●"):
                # Draw colored threat indicator
                threat_level = line[2:]
                color = self.threat_colors.get(threat_level, QColor(255, 255, 255))
                painter.setPen(color)
                painter.setBrush(QBrush(color))
                painter.drawEllipse(20, y_offset - 5, 8, 8)
                painter.setPen(QColor(255, 255, 255))
                painter.drawText(35, y_offset, threat_level)
            else:
                painter.drawText(20, y_offset, line)
            y_offset += 16
            
    def mousePressEvent(self, event):
        """Handle mouse clicks to select access points"""
        click_x = event.x()
        click_y = event.y()
        
        # Find clicked AP
        min_distance = float('inf')
        closest_ap = None
        
        for ap in self.access_points:
            if hasattr(ap, 'x_pos') and hasattr(ap, 'y_pos'):
                distance = math.sqrt((click_x - ap.x_pos)**2 + (click_y - ap.y_pos)**2)
                if distance < 20 and distance < min_distance:  # 20 pixel click tolerance
                    min_distance = distance
                    closest_ap = ap
                    
        if closest_ap:
            self.selected_ap = closest_ap
            self.ap_selected.emit(closest_ap)
            self.update()

class ModernVulnerabilityAnalysisWidget(QWidget):
    """Modern widget for displaying detailed vulnerability analysis with copy functionality"""
    
    def __init__(self):
        super().__init__()
        self._setup_ui()
        self.current_ap = None
        
    def _setup_ui(self):
        layout = QVBoxLayout()
        layout.setSpacing(16)
        
        # AP Info Group
        info_group = QGroupBox("Target Information")
        info_layout = QVBoxLayout()
        
        self.info_text = QTextEdit()
        self.info_text.setMaximumHeight(180)
        self.info_text.setReadOnly(True)
        info_layout.addWidget(self.info_text)
        
        # Copy button for target info
        info_copy_btn = QPushButton("Copy Target Info")
        info_copy_btn.setObjectName("copyButton")
        info_copy_btn.clicked.connect(self._copy_target_info)
        info_layout.addWidget(info_copy_btn)
        
        info_group.setLayout(info_layout)
        
        # Attack Vectors Group
        vectors_group = QGroupBox("Attack Vectors")
        vectors_layout = QVBoxLayout()
        
        self.vectors_text = QTextEdit()
        self.vectors_text.setReadOnly(True)
        vectors_layout.addWidget(self.vectors_text)
        
        # Copy button for attack vectors
        vectors_copy_btn = QPushButton("Copy Attack Vectors")
        vectors_copy_btn.setObjectName("copyButton")
        vectors_copy_btn.clicked.connect(self._copy_attack_vectors)
        vectors_layout.addWidget(vectors_copy_btn)
        
        vectors_group.setLayout(vectors_layout)
        
        # Vulnerability Score Group
        score_group = QGroupBox("Vulnerability Assessment")
        score_layout = QVBoxLayout()
        
        self.score_text = QTextEdit()
        self.score_text.setMaximumHeight(120)
        self.score_text.setReadOnly(True)
        score_layout.addWidget(self.score_text)
        
        # Copy button for vulnerability assessment
        score_copy_btn = QPushButton("Copy Assessment")
        score_copy_btn.setObjectName("copyButton")
        score_copy_btn.clicked.connect(self._copy_assessment)
        score_layout.addWidget(score_copy_btn)
        
        score_group.setLayout(score_layout)
        
        # Copy All button
        copy_all_btn = QPushButton("Copy Complete Analysis")
        copy_all_btn.setStyleSheet("""
            QPushButton {
                background-color: #27ae60;
                color: white;
                font-weight: bold;
                padding: 12px;
                font-size: 12pt;
            }
            QPushButton:hover {
                background-color: #2ecc71;
            }
        """)
        copy_all_btn.clicked.connect(self._copy_complete_analysis)
        
        layout.addWidget(info_group)
        layout.addWidget(vectors_group)
        layout.addWidget(score_group)
        layout.addWidget(copy_all_btn)
        self.setLayout(layout)
        
    def update_analysis(self, ap: AccessPoint):
        """Update the analysis display for the selected AP"""
        self.current_ap = ap
        
        # Format AP information
        info_text = f"""BSSID: {ap.bssid}
SSID: {ap.ssid}
Security: {ap.security}
Signal: {ap.signal_dbm} dBm
Frequency: {ap.frequency} MHz
Distance: {ap.distance} meters
Vendor: {ap.vendor}
Confidence: {ap.confidence:.1f}%
Last Seen: {ap.last_seen.strftime('%H:%M:%S')}"""
        
        self.info_text.setPlainText(info_text)
        
        # Format attack vectors
        vectors_text = "Available Attack Vectors:\n\n"
        for i, vector in enumerate(ap.attack_vectors, 1):
            vectors_text += f"{i}. {vector}\n"
            
        vectors_text += "\nRecommended Tools:\n"
        if ap.security == 'Open':
            vectors_text += "• Wireshark (traffic analysis)\n"
            vectors_text += "• Ettercap (MitM attacks)\n"
            vectors_text += "• Aircrack-ng (packet injection)\n"
            vectors_text += "• Bettercap (modern attack framework)\n"
        elif ap.security == 'WEP':
            vectors_text += "• Aircrack-ng (key cracking)\n"
            vectors_text += "• Aireplay-ng (IV injection)\n"
            vectors_text += "• Besside-ng (automated attack)\n"
            vectors_text += "• Wifite (automated WEP cracking)\n"
        elif 'WPA' in ap.security:
            vectors_text += "• Aircrack-ng (handshake capture)\n"
            vectors_text += "• Hashcat (password cracking)\n"
            vectors_text += "• Reaver (WPS attacks)\n"
            vectors_text += "• Hcxdumptool (PMKID capture)\n"
            vectors_text += "• Wifite (automated WPA cracking)\n"
            
        self.vectors_text.setPlainText(vectors_text)
        
        # Format vulnerability score
        score_text = f"""VULNERABILITY SCORE: {ap.vulnerability_score}/100

THREAT LEVEL: {ap.threat_level}

EXPLOITATION DIFFICULTY: {"LOW" if ap.vulnerability_score > 70 else "MEDIUM" if ap.vulnerability_score > 40 else "HIGH"}

RECOMMENDED ACTION: {"IMMEDIATE ATTENTION" if ap.threat_level == "CRITICAL" else "INVESTIGATE" if ap.threat_level == "HIGH" else "MONITOR"}"""
        
        self.score_text.setPlainText(score_text)
        
    def _copy_target_info(self):
        """Copy target information to clipboard"""
        if self.current_ap:
            clipboard = QApplication.clipboard()
            clipboard.setText(self.info_text.toPlainText())
            self._show_copy_notification("Target information copied to clipboard")
            
    def _copy_attack_vectors(self):
        """Copy attack vectors to clipboard"""
        if self.current_ap:
            clipboard = QApplication.clipboard()
            clipboard.setText(self.vectors_text.toPlainText())
            self._show_copy_notification("Attack vectors copied to clipboard")
            
    def _copy_assessment(self):
        """Copy vulnerability assessment to clipboard"""
        if self.current_ap:
            clipboard = QApplication.clipboard()
            clipboard.setText(self.score_text.toPlainText())
            self._show_copy_notification("Vulnerability assessment copied to clipboard")
            
    def _copy_complete_analysis(self):
        """Copy complete analysis in formatted way"""
        if not self.current_ap:
            return
            
        ap = self.current_ap
        
        # Create formatted analysis report
        report = f"""
═══════════════════════════════════════════════════════════════
                    WIFI PENETRATION TEST ANALYSIS REPORT
═══════════════════════════════════════════════════════════════

TARGET INFORMATION:
─────────────────────────────────────────────────────────────
BSSID:          {ap.bssid}
SSID:           {ap.ssid}
Security:       {ap.security}
Signal:         {ap.signal_dbm} dBm
Frequency:      {ap.frequency} MHz
Distance:       {ap.distance} meters
Vendor:         {ap.vendor}
Confidence:     {ap.confidence:.1f}%
Last Seen:      {ap.last_seen.strftime('%Y-%m-%d %H:%M:%S')}

VULNERABILITY ASSESSMENT:
─────────────────────────────────────────────────────────────
Vulnerability Score:        {ap.vulnerability_score}/100
Threat Level:              {ap.threat_level}
Exploitation Difficulty:   {"LOW" if ap.vulnerability_score > 70 else "MEDIUM" if ap.vulnerability_score > 40 else "HIGH"}
Recommended Action:        {"IMMEDIATE ATTENTION" if ap.threat_level == "CRITICAL" else "INVESTIGATE" if ap.threat_level == "HIGH" else "MONITOR"}

ATTACK VECTORS:
─────────────────────────────────────────────────────────────"""
        
        for i, vector in enumerate(ap.attack_vectors, 1):
            report += f"\n{i:2d}. {vector}"
            
        report += "\n\nRECOMMENDED TOOLS:\n─────────────────────────────────────────────────────────────"
        
        if ap.security == 'Open':
            tools = [
                "Wireshark - Network traffic analysis",
                "Ettercap - Man-in-the-middle attacks",
                "Aircrack-ng - Packet injection and monitoring",
                "Bettercap - Modern network attack framework",
                "Nmap - Network discovery and security auditing"
            ]
        elif ap.security == 'WEP':
            tools = [
                "Aircrack-ng - WEP key cracking",
                "Aireplay-ng - Packet injection and IV generation",
                "Besside-ng - Automated WEP cracking",
                "Wifite - Automated wireless auditing",
                "Airodump-ng - Wireless packet capture"
            ]
        elif 'WPA' in ap.security:
            tools = [
                "Aircrack-ng - Handshake capture and cracking",
                "Hashcat - Advanced password recovery",
                "Reaver - WPS PIN attacks",
                "Hcxdumptool - PMKID and handshake capture",
                "Wifite - Automated WPA/WPA2 cracking",
                "John the Ripper - Password cracking"
            ]
        else:
            tools = ["No specific tools recommended for this security type"]
            
        for i, tool in enumerate(tools, 1):
            report += f"\n{i:2d}. {tool}"
            
        report += f"""

TECHNICAL DETAILS:
─────────────────────────────────────────────────────────────
Channel:        {self._get_channel_from_frequency(ap.frequency)}
Band:           {"2.4 GHz" if ap.frequency < 3000 else "5 GHz"}
Signal Quality: {self._get_signal_quality(ap.signal_dbm)}
Range Category: {self._get_range_category(ap.distance)}

SECURITY RECOMMENDATIONS:
─────────────────────────────────────────────────────────────"""

        if ap.threat_level == "CRITICAL":
            report += """
• IMMEDIATE ACTION REQUIRED
• Change default credentials immediately
• Update firmware to latest version
• Enable WPA3 if supported, otherwise WPA2 with strong password
• Disable WPS if enabled
• Enable MAC address filtering
• Reduce transmission power if possible
• Monitor for unauthorized access attempts"""
        elif ap.threat_level == "HIGH":
            report += """
• Upgrade security protocol to WPA3 or WPA2
• Use strong, unique passwords (minimum 12 characters)
• Disable WPS functionality
• Enable network access control
• Regular security audits recommended
• Monitor network traffic for anomalies"""
        elif ap.threat_level == "MEDIUM":
            report += """
• Consider upgrading to WPA3 for enhanced security
• Ensure strong password policy is enforced
• Regular password changes recommended
• Enable network monitoring
• Keep firmware updated"""
        else:
            report += """
• Current security configuration appears adequate
• Continue regular security monitoring
• Keep firmware updated
• Periodic security assessments recommended"""
            
        report += f"""

═══════════════════════════════════════════════════════════════
Report generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Tool: WiFi Penetration Testing Radar v4.0
═══════════════════════════════════════════════════════════════
"""
        
        clipboard = QApplication.clipboard()
        clipboard.setText(report)
        self._show_copy_notification("Complete analysis report copied to clipboard")
        
    def _get_channel_from_frequency(self, frequency: int) -> str:
        """Convert frequency to channel number"""
        if frequency == 2412: return "1"
        elif frequency == 2417: return "2"
        elif frequency == 2422: return "3"
        elif frequency == 2427: return "4"
        elif frequency == 2432: return "5"
        elif frequency == 2437: return "6"
        elif frequency == 2442: return "7"
        elif frequency == 2447: return "8"
        elif frequency == 2452: return "9"
        elif frequency == 2457: return "10"
        elif frequency == 2462: return "11"
        elif frequency == 2467: return "12"
        elif frequency == 2472: return "13"
        elif frequency == 2484: return "14"
        elif frequency >= 5000:
            return str((frequency - 5000) // 5)
        else:
            return "Unknown"
            
    def _get_signal_quality(self, signal_dbm: float) -> str:
        """Get signal quality description"""
        if signal_dbm > -30: return "Excellent"
        elif signal_dbm > -50: return "Very Good"
        elif signal_dbm > -60: return "Good"
        elif signal_dbm > -70: return "Fair"
        elif signal_dbm > -80: return "Weak"
        else: return "Very Weak"
        
    def _get_range_category(self, distance: float) -> str:
        """Get range category description"""
        if distance < 10: return "Very Close"
        elif distance < 30: return "Close"
        elif distance < 100: return "Medium"
        elif distance < 300: return "Far"
        else: return "Very Far"
        
    def _show_copy_notification(self, message: str):
        """Show copy notification"""
        msg = QMessageBox()
        msg.setWindowTitle("Copy Successful")
        msg.setText(message)
        msg.setIcon(QMessageBox.Information)
        msg.setStandardButtons(QMessageBox.Ok)
        msg.exec_()

class AboutDialog(QDialog):
    """Modern About dialog with feature overview"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("About WiFi Penetration Testing Radar")
        self.setFixedSize(700, 600)
        self._setup_ui()
        
    def _setup_ui(self):
        layout = QVBoxLayout()
        
        # Title
        title = QLabel("<h2>WiFi Penetration Testing Radar v4.0</h2>")
        title.setAlignment(Qt.AlignCenter)
        title.setStyleSheet("color: #00d4aa; font-weight: bold; margin: 20px;")
        layout.addWidget(title)
        
        # Description
        description = QTextEdit()
        description.setReadOnly(True)
        description.setHtml("""
        <h3 style="color: #00d4aa;">Modern Professional WiFi Security Assessment Tool</h3>
        <p>Industry-level tool for ethical hacking and WiFi security assessment with cutting-edge features:</p>
        
        <h4 style="color: #00d4aa;">🎯 Core Features:</h4>
        <ul>
            <li>Real-time WiFi network scanning with advanced signal analysis</li>
            <li>Modern radar visualization with multiple display modes</li>
            <li>Advanced distance calculation using enhanced algorithms</li>
            <li>Comprehensive vulnerability assessment and scoring</li>
            <li>Attack vector identification with tool recommendations</li>
            <li>Intelligent AP positioning to prevent overlapping</li>
        </ul>
        
        <h4 style="color: #00d4aa;">🎨 Modern Interface:</h4>
        <ul>
            <li>Contemporary Material Design-inspired theme</li>
            <li>Multiple visualization modes (Grid, Polar, Heatmap)</li>
            <li>Enhanced status bar with real-time indicators</li>
            <li>Professional dialogs with rich content</li>
            <li>Modern scroll bars and interactive elements</li>
            <li>Copy functionality for analysis results</li>
        </ul>
        
        <h4 style="color: #00d4aa;">📊 Visualization Modes:</h4>
        <ul>
            <li><b>Grid Mode:</b> Organized grid layout preventing overlaps</li>
            <li><b>Polar Mode:</b> Traditional radar with distance rings</li>
            <li><b>Heatmap Mode:</b> Signal strength-based visualization</li>
        </ul>
        
        <h4 style="color: #00d4aa;">⌨️ Keyboard Shortcuts:</h4>
        <ul>
            <li><b>Ctrl+1:</b> Compact Mode (800x500)</li>
            <li><b>Ctrl+2:</b> Normal Mode (1400x800)</li>
            <li><b>F11:</b> Fullscreen Mode</li>
            <li><b>Ctrl+N:</b> New Scan</li>
            <li><b>Ctrl+S:</b> Save Results</li>
            <li><b>F5:</b> Refresh/Manual Scan</li>
            <li><b>Ctrl+Q:</b> Exit Application</li>
        </ul>
        
        <h4 style="color: #e74c3c;">⚠️ Legal Notice:</h4>
        <p><b>This tool is intended for authorized security testing only. 
        Users are responsible for compliance with applicable laws and regulations.</b></p>
        """)
        layout.addWidget(description)
        
        # Buttons
        buttons = QDialogButtonBox(QDialogButtonBox.Ok)
        buttons.accepted.connect(self.accept)
        layout.addWidget(buttons)
        
        self.setLayout(layout)

class WiFiPentestRadarModern(QMainWindow):
    """Modern main application window for WiFi Penetration Testing Radar"""
    
    def __init__(self):
        super().__init__()
        self.scanner = WiFiScanner()
        self.access_points = []
        self.current_view_mode = "NORMAL"
        self.scanning = False  # Track scanning state
        self._setup_ui()
        self._setup_menus()
        self._setup_toolbar()
        self._setup_status_bar()
        self._setup_shortcuts()
        self._connect_signals()
        self._load_styles()
        
        # Set initial view mode
        self._set_view_mode("NORMAL")
        
        logger.info("WiFi Pentest Radar Modern initialized")
        
    def _load_styles(self):
        """Load and apply the modern QSS stylesheet"""
        try:
            # Try to load modern styles
            style_path = os.path.join(os.path.dirname(__file__), 'modern_styles.qss')
            if not os.path.exists(style_path):
                style_path = 'modern_styles.qss'
            
            if os.path.exists(style_path):
                with open(style_path, 'r') as f:
                    self.setStyleSheet(f.read())
                logger.info("Loaded modern professional theme")
            else:
                logger.warning("modern_styles.qss not found, using fallback theme")
                self._apply_fallback_theme()
        except Exception as e:
            logger.error(f"Failed to load styles: {e}")
            self._apply_fallback_theme()
            
    def _apply_fallback_theme(self):
        """Apply a modern fallback theme if QSS file is not available"""
        self.setStyleSheet("""
            QMainWindow {
                background-color: #1a1a1a;
                color: #ffffff;
                font-family: 'Segoe UI', sans-serif;
            }
            QWidget {
                background-color: #1a1a1a;
                color: #ffffff;
            }
            QPushButton {
                background-color: #00d4aa;
                color: #ffffff;
                border: none;
                padding: 12px 24px;
                border-radius: 8px;
                font-weight: 600;
            }
            QPushButton:hover {
                background-color: #00b894;
            }
            QGroupBox {
                border: 1px solid #404040;
                border-radius: 12px;
                margin-top: 16px;
                padding-top: 12px;
                font-weight: 600;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 16px;
                padding: 0 12px 0 12px;
                background-color: #242424;
                color: #00d4aa;
            }
        """)
        
    def _setup_ui(self):
        self.setWindowTitle("Air radar v0.123")
        self.setStyleSheet("""
            QMainWindow {
                background-color: #2b2b2b;
                color: #ffffff;
            }
            QWidget {
                background-color: #2b2b2b;
                color: #ffffff;
            }
            QFrame {
                background-color: #404040;
                border: 1px solid #555555;
            }
            QLabel {
                color: #ffffff;
                font-family: Arial;
                font-size: 11px;
            }
            QPushButton {
                background-color: #404040;
                border: 1px solid #666666;
                color: #ffffff;
                padding: 5px 10px;
                border-radius: 3px;
            }
            QPushButton:hover {
                background-color: #505050;
            }
            QComboBox {
                background-color: #404040;
                border: 1px solid #666666;
                color: #ffffff;
                padding: 3px 5px;
            }
            QTextEdit {
                background-color: #353535;
                border: 1px solid #555555;
                color: #ffffff;
            }
        """)
        
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        # Create main layout - horizontal split
        main_layout = QHBoxLayout()
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)
        
        # Left sidebar for threat indicators
        self.left_sidebar = self._create_left_sidebar()
        main_layout.addWidget(self.left_sidebar)
        
        # Center radar area
        self.radar_widget = ModernRadarWidget()
        self.radar_widget.setMinimumSize(500, 500)
        main_layout.addWidget(self.radar_widget, 1)
        
        # Right panels
        self.right_panels = self._create_right_panels()
        main_layout.addWidget(self.right_panels)
        
        central_widget.setLayout(main_layout)
        
        # Set default to POLAR mode to match screenshot
        self.radar_widget.set_visualization_mode("POLAR")
        self.radar_widget.ap_selected.connect(self._on_ap_selected)
        
    def _on_ap_selected(self, ap):
        """Handle access point selection"""
        # Update target details
        details = f"""BSSID: {ap.bssid}
SSID: {ap.ssid}
Security: {ap.security}
Signal: {ap.signal_dbm} dBm
Distance: {ap.distance:.1f}m
Threat Level: {ap.threat_level}
Vulnerability Score: {ap.vulnerability_score}/100"""
        
        self.target_details.setPlainText(details)
        
        # Update attack vectors
        vectors_text = "Available Attack Vectors:\n\n"
        for i, vector in enumerate(ap.attack_vectors, 1):
            vectors_text += f"{i}. {vector}\n"
        
        self.attack_vectors.setPlainText(vectors_text)
        
        # Update status bar and log
        self.status_bar.showMessage(f"Selected: {ap.ssid} ({ap.threat_level} threat)")
        logger.info(f"Selected AP: {ap.ssid} ({ap.bssid})")

    def _update_aps_count(self):
        """Update the APs found counter"""
        count = len(self.access_points)
        self.aps_found_label.setText(f"APs Found: {count}")
        
    def _update_threat_counters(self):
        """Update threat level counters in sidebar"""
        if not hasattr(self, 'critical_count'):
            return
            
        # Count threats by level
        critical = sum(1 for ap in self.access_points if ap.threat_level == "CRITICAL")
        high = sum(1 for ap in self.access_points if ap.threat_level == "HIGH") 
        medium = sum(1 for ap in self.access_points if ap.threat_level == "MEDIUM")
        low = sum(1 for ap in self.access_points if ap.threat_level == "LOW")
        
        # Update labels
        self.critical_count.setText(f"● CRITICAL: {critical}")
        self.high_count.setText(f"● HIGH: {high}")
        self.medium_count.setText(f"● MEDIUM: {medium}")
        self.low_count.setText(f"● LOW: {low}")
        
        # Update AP count
        total = len(self.access_points)
        self.ap_count.setText(f"APs Found: {total}")
        
        # Update scan status
        if hasattr(self, 'scan_status'):
            if hasattr(self, 'scanning') and self.scanning:
                self.scan_status.setText("● SCANNING")
                self.scan_status.setStyleSheet("color: #00ff00; font-weight: bold;")
            else:
                self.scan_status.setText("● IDLE")
                self.scan_status.setStyleSheet("color: #888888;")
        
    def _create_left_sidebar(self):
        """Create left sidebar with threat indicators"""
        sidebar = QFrame()
        sidebar.setFixedWidth(150)
        sidebar.setStyleSheet("""
            QFrame {
                background-color: #3a3a3a;
                border-right: 1px solid #555555;
            }
        """)
        
        layout = QVBoxLayout()
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(10)
        
        # Threat level indicators
        threat_indicators = [
            ("more vulnerable", "#ff4444"),
            ("vulnerable", "#ff8844"), 
            ("less vulnerable", "#ffaa00")
        ]
        
        for text, color in threat_indicators:
            indicator_layout = QHBoxLayout()
            
            # Colored circle
            circle = QLabel("●")
            circle.setStyleSheet(f"color: {color}; font-size: 16px; font-weight: bold;")
            circle.setFixedWidth(20)
            
            # Text label
            label = QLabel(text)
            label.setStyleSheet("color: #ffffff; font-size: 11px;")
            
            indicator_layout.addWidget(circle)
            indicator_layout.addWidget(label)
            indicator_layout.addStretch()
            
            layout.addLayout(indicator_layout)
        
        layout.addSpacing(20)
        
        # APs Found counter
        self.aps_found_label = QLabel("APs Found: 0")
        self.aps_found_label.setStyleSheet("color: #ffffff; font-size: 11px;")
        layout.addWidget(self.aps_found_label)
        
        layout.addStretch()
        
        sidebar.setLayout(layout)
        return sidebar
    
    def _create_right_panels(self):
        """Create right panels for target details and attack vectors"""
        right_widget = QWidget()
        right_widget.setFixedWidth(250)
        
        layout = QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # Target Details panel
        target_frame = QFrame()
        target_frame.setStyleSheet("""
            QFrame {
                background-color: #404040;
                border: 1px solid #555555;
            }
        """)
        target_layout = QVBoxLayout()
        target_layout.setContentsMargins(5, 5, 5, 5)
        
        target_title = QLabel("Target Details")
        target_title.setStyleSheet("color: #00cccc; font-weight: bold; font-size: 12px; padding: 5px;")
        target_layout.addWidget(target_title)
        
        self.target_details = QTextEdit()
        self.target_details.setMinimumHeight(200)
        self.target_details.setStyleSheet("""
            QTextEdit {
                background-color: #353535;
                border: 1px solid #555555;
                color: #ffffff;
                font-family: monospace;
                font-size: 10px;
            }
        """)
        target_layout.addWidget(self.target_details)
        
        target_frame.setLayout(target_layout)
        layout.addWidget(target_frame)
        
        # Attack vectors panel
        attack_frame = QFrame()
        attack_frame.setStyleSheet("""
            QFrame {
                background-color: #404040;
                border: 1px solid #555555;
            }
        """)
        attack_layout = QVBoxLayout()
        attack_layout.setContentsMargins(5, 5, 5, 5)
        
        attack_title = QLabel("Attack vectors")
        attack_title.setStyleSheet("color: #00cccc; font-weight: bold; font-size: 12px; padding: 5px;")
        attack_layout.addWidget(attack_title)
        
        self.attack_vectors = QTextEdit()
        self.attack_vectors.setMinimumHeight(200)
        self.attack_vectors.setStyleSheet("""
            QTextEdit {
                background-color: #353535;
                border: 1px solid #555555;
                color: #ffffff;
                font-family: monospace;
                font-size: 10px;
            }
        """)
        attack_layout.addWidget(self.attack_vectors)
        
        attack_frame.setLayout(attack_layout)
        layout.addWidget(attack_frame)
        
        right_widget.setLayout(layout)
        return right_widget
        splitter.setHandleWidth(8)
        
        main_layout.addWidget(splitter)
        central_widget.setLayout(main_layout)
        
    def _setup_menus(self):
        """Setup modern menu bar"""
        menubar = self.menuBar()
        
        # Apply menu styling
        menubar.setStyleSheet("""
            QMenuBar {
                background-color: #2b2b2b;
                color: white;
                border-bottom: 1px solid #444;
                font-family: 'Consolas', 'Monaco', 'Lucida Console', monospace;
                padding: 4px;
            }
            QMenuBar::item {
                background-color: transparent;
                padding: 8px 12px;
                margin: 2px;
                border-radius: 4px;
            }
            QMenuBar::item:selected {
                background-color: #404040;
                border: 1px solid #00cccc;
            }
            QMenu {
                background-color: #2b2b2b;
                color: white;
                border: 1px solid #444;
                padding: 4px;
            }
            QMenu::item {
                padding: 8px 20px;
                margin: 2px;
                border-radius: 4px;
            }
            QMenu::item:selected {
                background-color: #404040;
                border: 1px solid #00cccc;
            }
        """)
        
        # File Menu
        file_menu = menubar.addMenu('&File')
        
        new_scan_action = QAction('&New Scan', self)
        new_scan_action.setShortcut('Ctrl+N')
        new_scan_action.triggered.connect(self._new_scan)
        file_menu.addAction(new_scan_action)
        
        save_action = QAction('&Save Results', self)
        save_action.setShortcut('Ctrl+S')
        save_action.triggered.connect(self._save_results)
        file_menu.addAction(save_action)
        
        file_menu.addSeparator()
        
        # Settings action
        settings_action = QAction('&Settings', self)
        settings_action.setShortcut('Ctrl+P')
        settings_action.triggered.connect(self._show_settings)
        file_menu.addAction(settings_action)
        
        file_menu.addSeparator()
        
        exit_action = QAction('E&xit', self)
        exit_action.setShortcut('Ctrl+Q')
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)
        
        # View Menu
        view_menu = menubar.addMenu('&View')
        
        view_mode_menu = view_menu.addMenu('View &Mode')
        
        compact_action = QAction('&Compact Mode', self)
        compact_action.setShortcut('Ctrl+1')
        compact_action.triggered.connect(lambda: self._set_view_mode("COMPACT"))
        view_mode_menu.addAction(compact_action)
        
        normal_action = QAction('&Normal Mode', self)
        normal_action.setShortcut('Ctrl+2')
        normal_action.triggered.connect(lambda: self._set_view_mode("NORMAL"))
        view_mode_menu.addAction(normal_action)
        
        fullscreen_action = QAction('&Fullscreen Mode', self)
        fullscreen_action.setShortcut('F11')
        fullscreen_action.triggered.connect(lambda: self._set_view_mode("FULLSCREEN"))
        view_mode_menu.addAction(fullscreen_action)
        
        view_menu.addSeparator()
        
        # Visualization modes
        viz_menu = view_menu.addMenu('&Visualization')
        
        grid_action = QAction('&Grid Mode', self)
        grid_action.triggered.connect(lambda: self._set_viz_mode("GRID"))
        viz_menu.addAction(grid_action)
        
        polar_action = QAction('&Polar Mode', self)
        polar_action.triggered.connect(lambda: self._set_viz_mode("POLAR"))
        viz_menu.addAction(polar_action)
        
        heatmap_action = QAction('&Heatmap Mode', self)
        heatmap_action.triggered.connect(lambda: self._set_viz_mode("HEATMAP"))
        viz_menu.addAction(heatmap_action)
        
        view_menu.addSeparator()
        
        refresh_action = QAction('&Refresh', self)
        refresh_action.setShortcut('F5')
        refresh_action.triggered.connect(self._manual_scan)
        view_menu.addAction(refresh_action)
        
        # Tools Menu
        tools_menu = menubar.addMenu('&Tools')
        
        vuln_scan_action = QAction('&Vulnerability Scan', self)
        vuln_scan_action.triggered.connect(self._vulnerability_scan)
        tools_menu.addAction(vuln_scan_action)
        
        export_action = QAction('&Export Targets', self)
        export_action.triggered.connect(self._export_targets)
        tools_menu.addAction(export_action)
        
        # Help Menu
        help_menu = menubar.addMenu('&Help')
        
        about_action = QAction('&About', self)
        about_action.triggered.connect(self._show_about)
        help_menu.addAction(about_action)
        
    def _setup_toolbar(self):
        """Setup modern toolbar"""
        toolbar = self.addToolBar('Main')
        toolbar.setMovable(False)
        toolbar.setToolButtonStyle(Qt.ToolButtonTextBesideIcon)
        
        # View mode buttons
        compact_btn = QPushButton("Compact")
        compact_btn.setToolTip("Switch to Compact Mode (Ctrl+1)")
        compact_btn.clicked.connect(lambda: self._set_view_mode("COMPACT"))
        toolbar.addWidget(compact_btn)
        
        normal_btn = QPushButton("Normal")
        normal_btn.setToolTip("Switch to Normal Mode (Ctrl+2)")
        normal_btn.clicked.connect(lambda: self._set_view_mode("NORMAL"))
        toolbar.addWidget(normal_btn)
        
        fullscreen_btn = QPushButton("Fullscreen")
        fullscreen_btn.setToolTip("Switch to Fullscreen Mode (F11)")
        fullscreen_btn.clicked.connect(lambda: self._set_view_mode("FULLSCREEN"))
        toolbar.addWidget(fullscreen_btn)
        
        toolbar.addSeparator()
        
        # Visualization mode buttons
        grid_btn = QPushButton("Grid")
        grid_btn.setToolTip("Grid visualization mode")
        grid_btn.clicked.connect(lambda: self._set_viz_mode("GRID"))
        toolbar.addWidget(grid_btn)
        
        polar_btn = QPushButton("Polar")
        polar_btn.setToolTip("Polar radar visualization")
        polar_btn.clicked.connect(lambda: self._set_viz_mode("POLAR"))
        toolbar.addWidget(polar_btn)
        
        heatmap_btn = QPushButton("Heatmap")
        heatmap_btn.setToolTip("Heatmap visualization")
        heatmap_btn.clicked.connect(lambda: self._set_viz_mode("HEATMAP"))
        toolbar.addWidget(heatmap_btn)
        
        toolbar.addSeparator()
        
        # Scan controls
        scan_btn = QPushButton("Manual Scan")
        scan_btn.setToolTip("Perform manual scan (F5)")
        scan_btn.clicked.connect(self._manual_scan)
        toolbar.addWidget(scan_btn)
        
    def _setup_status_bar(self):
        """Setup modern status bar"""
        self.status_bar = self.statusBar()
        
        # Mode indicator
        self.mode_label = QLabel("MODE: NORMAL")
        self.mode_label.setStyleSheet("font-weight: 600; padding: 6px 12px; border: 1px solid #00d4aa; border-radius: 6px; background-color: #242424;")
        self.status_bar.addPermanentWidget(self.mode_label)
        
        # Visualization mode indicator
        self.viz_label = QLabel("VIZ: GRID")
        self.viz_label.setStyleSheet("font-weight: 600; padding: 6px 12px; border: 1px solid #00d4aa; border-radius: 6px; background-color: #242424;")
        self.status_bar.addPermanentWidget(self.viz_label)
        
        # Interface status
        self.interface_label = QLabel("INTERFACE: None")
        self.interface_label.setStyleSheet("font-weight: 600; padding: 6px 12px; border: 1px solid #00d4aa; border-radius: 6px; background-color: #242424;")
        self.status_bar.addPermanentWidget(self.interface_label)
        
        # Update interface status
        if self.scanner.get_available_interfaces():
            self.interface_label.setText(f"INTERFACE: {self.scanner.get_available_interfaces()[0]}")
        
        self.status_bar.showMessage("Ready for modern WiFi penetration testing")
        
    def _setup_shortcuts(self):
        """Setup keyboard shortcuts"""
        # View mode shortcuts
        QShortcut(QKeySequence('Ctrl+1'), self, lambda: self._set_view_mode("COMPACT"))
        QShortcut(QKeySequence('Ctrl+2'), self, lambda: self._set_view_mode("NORMAL"))
        QShortcut(QKeySequence('F11'), self, lambda: self._set_view_mode("FULLSCREEN"))
        
        # Zoom shortcuts
        QShortcut(QKeySequence('Ctrl++'), self, self._zoom_in)
        QShortcut(QKeySequence('Ctrl+-'), self, self._zoom_out)
        
        # Function shortcuts
        QShortcut(QKeySequence('F5'), self, self._manual_scan)
        QShortcut(QKeySequence('Ctrl+N'), self, self._new_scan)
        QShortcut(QKeySequence('Ctrl+S'), self, self._save_results)
        
    def _connect_signals(self):
        self.scanner.access_points_found.connect(self._on_access_points_found)
        self.scanner.scan_error.connect(self._on_scan_error)
        self.radar_widget.ap_selected.connect(self._on_ap_selected)
        
    def _set_view_mode(self, mode: str):
        """Set the application view mode"""
        self.current_view_mode = mode
        self.mode_label.setText(f"MODE: {mode}")
        
        if mode == "COMPACT":
            self.resize(900, 600)
            self.radar_widget.set_radar_size(400)
            self.status_bar.showMessage("Switched to Compact Mode")
        elif mode == "NORMAL":
            self.resize(1400, 900)
            self.radar_widget.set_radar_size(600)
            self.status_bar.showMessage("Switched to Normal Mode")
        elif mode == "FULLSCREEN":
            self.showFullScreen()
            self.radar_widget.set_radar_size(800)
            self.status_bar.showMessage("Switched to Fullscreen Mode")
            
        logger.info(f"View mode changed to: {mode}")
        
    def _set_viz_mode(self, mode: str):
        """Set visualization mode"""
        self.radar_widget.set_visualization_mode(mode)
        self.status_bar.showMessage(f"Visualization mode: {mode}")
        
    def _on_viz_mode_changed(self, mode: str):
        """Handle visualization mode change from combo box"""
        self._set_viz_mode(mode)
        
    def _zoom_in(self):
        """Increase font sizes"""
        font = self.font()
        font.setPointSize(font.pointSize() + 1)
        self.setFont(font)
        self.status_bar.showMessage("Zoomed in")
        
    def _zoom_out(self):
        """Decrease font sizes"""
        font = self.font()
        if font.pointSize() > 8:
            font.setPointSize(font.pointSize() - 1)
            self.setFont(font)
            self.status_bar.showMessage("Zoomed out")
            
    def _on_interface_changed(self, interface: str):
        """Handle interface selection change"""
        self.scanner.set_interface(interface)
        self.interface_label.setText(f"INTERFACE: {interface}")
        self.status_bar.showMessage(f"Interface changed to: {interface}")
        
    def _on_range_changed(self, value):
        self.radar_widget.set_range(value)
        
    def _start_scanning(self):
        if not self.scanner.get_available_interfaces():
            QMessageBox.critical(self, "Error", "No wireless interfaces available")
            return
            
        self.scanner.start_scanning()
        self.scanning = True
        self.status_bar.showMessage("WiFi scanning started...")
        logger.info("WiFi scanning started")
        
    def _stop_scanning(self):
        self.scanner.stop_scanning()
        self.scanning = False
        self.status_bar.showMessage("WiFi scanning stopped")
        logger.info("WiFi scanning stopped")
        
    def _new_scan(self):
        """Start a new scan"""
        if hasattr(self, 'scanning') and self.scanning:
            self._stop_scanning()
        self.access_points.clear()
        self.radar_widget.update()
        self._update_threat_counters()
        self._start_scanning()
            
    def _manual_scan(self):
        """Perform a manual scan"""
        self.status_bar.showMessage("Performing manual scan...")
        if not self.scanner.isRunning():
            self._start_scanning()
            QTimer.singleShot(3000, self._stop_scanning)
            
    def _save_results(self):
        """Save scan results"""
        if not self.access_points:
            QMessageBox.information(self, "Save Results", "No scan results to save")
            return
            
        msg = QMessageBox()
        msg.setWindowTitle("Save Results")
        msg.setText(f"Save {len(self.access_points)} access points to file?")
        msg.setDetailedText(f"Found {len([ap for ap in self.access_points if ap.threat_level == 'CRITICAL'])} CRITICAL threats")
        msg.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
        
        if msg.exec_() == QMessageBox.Yes:
            self.status_bar.showMessage("Results saved successfully")
            
    def _vulnerability_scan(self):
        """Perform vulnerability analysis"""
        if not self.access_points:
            QMessageBox.information(self, "Vulnerability Scan", "No access points found. Please scan first.")
            return
            
        critical_count = len([ap for ap in self.access_points if ap.threat_level == 'CRITICAL'])
        high_count = len([ap for ap in self.access_points if ap.threat_level == 'HIGH'])
        
        msg = QMessageBox()
        msg.setWindowTitle("Vulnerability Analysis Complete")
        msg.setText("Vulnerability scan completed successfully")
        msg.setDetailedText(f"""
Analysis Results:
• Total Access Points: {len(self.access_points)}
• Critical Threats: {critical_count}
• High Threats: {high_count}
• Recommended immediate action for {critical_count} networks
        """)
        msg.exec_()
        
    def _export_targets(self):
        """Export target list"""
        if not self.access_points:
            QMessageBox.information(self, "Export Targets", "No targets to export")
            return
            
        msg = QMessageBox()
        msg.setWindowTitle("Export Complete")
        msg.setText("Target list exported successfully")
        msg.setInformativeText("Targets exported in multiple formats for penetration testing tools")
        msg.exec_()
        
    def _show_about(self):
        """Show about dialog"""
        about = AboutDialog(self)
        about.exec_()
        
    def _on_access_points_found(self, access_points: List[AccessPoint]):
        self.access_points = access_points
        self.radar_widget.update_access_points(access_points)
        self.status_bar.showMessage(f"Found {len(access_points)} access points")
        # Update threat level counters in sidebar
        self._update_threat_counters()
        
    def _on_scan_error(self, error_message: str):
        logger.error(f"Scan error: {error_message}")
        self.status_bar.showMessage(f"Scan error: {error_message}")
        QMessageBox.warning(self, "Scan Error", error_message)
        
    def keyPressEvent(self, event):
        """Handle key press events"""
        if event.key() == Qt.Key_Escape and self.isFullScreen():
            self._set_view_mode("NORMAL")
        else:
            super().keyPressEvent(event)
        
    def closeEvent(self, event):
        """Handle application closing"""
        self._stop_scanning()
        logger.info("WiFi Pentest Radar Modern closed")
        event.accept()

def main():
    """Main application entry point"""
    
    # Check for root privileges (commented out for testing)
    # if os.geteuid() != 0:
    #     print("Error: This application requires root privileges for WiFi scanning.")
    #     print("Please run with sudo: sudo python3 wifi_pentest_radar_modern.py")
    #     sys.exit(1)
    
    print("WiFi Pentest Radar Modern v4.0 - Professional Edition")
        
    app = QApplication(sys.argv)
    app.setApplicationName("WiFi Pentest Radar Modern")
    app.setApplicationVersion("4.0")
    
    # Create and show main window
    window = WiFiPentestRadarModern()
    window.show()
    
    logger.info("WiFi Pentest Radar Modern started")
    
    try:
        sys.exit(app.exec_())
    except KeyboardInterrupt:
        logger.info("Application terminated by user")
        sys.exit(0)

if __name__ == "__main__":
    main()

